[<< 메인으로](https://github.com/AtomicLiquors/Java_Wiki_Chb)

&nbsp;  


# 실수형
> 실수를 저장하기 위한 타입이다.



*double* : 더 큰 값의 범위나 더 큰 정밀도가 필요할 때 사용한다.  
소수를 쓰고 아무것도 달지 않는다.
&nbsp;  
*float* : 연산 속도나 메모리가 우선일 때 사용한다.  
소수를 쓰고 f를 달아준다.

```java
double dnum = 2.15;
float fnum = 3.15f;
```

소수점 두자리
```java
System.out.printf("원기둥의 부피: %.2f\n", c.getVolume());  
```
&nbsp;  


|타입|저장 가능한 범위(양수)|정밀도|bit수|byte수|
|--|--|--|--|--|
|float|$1.4 * 10^{-45}$ ~ $3.4 *10^{38}$|7자리|32|4|
|double|$4.49* 10^{-324}$ ~ $1.8 *10^{308}$|15자리|64|8|

실수형은 소수점수도 표현해야 하기 때문에,  
얼마나 큰 값을 표현할 수 있는가? 만큼이나  
얼마나 0과 가깝게 표현할 수 있는가? 도 중요하다.

실수형에서는 Overflow가 발생하면 변수 값이 무한대가 된다.

실수형에서는 Underflow 또한 존재한다.  
실수형으로 표현 불가능할만큼 정말 작은 값이 되는 경우.  
(실수형의 양의 최솟값보다 더 작은 값이 되는 경우.)  
이 때 변수 값은 0이 된다.

&nbsp;  
Q. 어떻게 같은 4바이트인데 표현 범위가 그렇게 넓나요?  
A. 값을 저장하는 형식이 다르기 때문이다.  
실수형은 부호($S$), 지수($E$), 가수($M$) 세 부분으로 나뉘어 있다.  
저장은 다음과 같이 '10의 제곱을 곱한 형태'로 저장된다.

$(±M * 10^E)$

이는 IEEE754라는 표준을 따른 것이다.


&nbsp;  

**정밀도**  
정밀도가 $n$자리라는 말은, $n$자리의 10진수를 오차 없이 저장할 수 있다는 뜻이다.  
double 타입은 정밀도가 15자리이며,  
double을 쓰는 이유는 값이 더 크거나 작아서가 아니라  
소수 자릿수가 늘어나도 오차가 적고 정확하기 때문이다.  
double이라는 이름도 'float보다 2배 정도는 정밀하다'는 의미이다.

&nbsp;  

```java
public static void main(String[] args) {
		System.out.println(10.0 == 10.0f);
		System.out.println(0.1==0.1f);
	}
```
```
출력 결과:
true
false
```

Q. 10.0 == 10.0f는 true인데, 0.1 == 0.1f는 왜 false인가요?  
A. 정수형과 달리, 실수형은 근삿값으로 저장되므로 오차가 발생할 수 있다.  

float 타입을 double타입으로 바꿔봤자 정밀도가 더 높아지는 것도   아니고,  
오차가 줄어드는 것도 아니다.  

서로 타입이 다른 두 항에 대해 이항연산자인 ==를 사용했을 때 형변환을 실행할 텐데,  
float 타입을 double 타입으로 형변환하면 가수의 빈자리를 0으로 채운다.  
부호와 지수는 달라지지 않고, 값도 전혀 달라지지 않는다.  


밑에 코드는 국비인거 같은데 오차 때문에 쓰는 건가?

```jsx
public class DoubleTest01 {
	public static void main(String[] args) {
		double dnum = 0;
		for (int i = 0; i < 10000; i++) {
			dnum = dnum + 0.01;
		}
		System.out.println(dnum);
	}
}
```



가수? 공부 좀 다시 해보자.  
실수형에 대해서는 복습하고,  
연산자 관련된 해당 내용 해설은 자바의 정석 111페이지.


**보충) 자바의 정석 70페이지 보기.**

