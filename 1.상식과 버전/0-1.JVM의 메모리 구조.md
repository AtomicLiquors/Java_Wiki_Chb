[<< 메인으로](https://github.com/AtomicLiquors/Java_Wiki_Chb/blob/main/Readme.md)


# JVM의 메모리 구조
```
.java파일 - 자연어 -> [컴파일러] - Byte Code -> [JVM] - 기계어 -> [OS]
```

JVM의 역할은 **자바 애플리케이션을 클래스 로더로 읽어들여 자바 API와 함께 실행하는 것**이다.   
JVM의 해석을 거친다는 점 때문에 c언어 같은 네이티브 언어에 비해 속도가 느렸다.
이런 단점은 JIT(Just In Time)컴파일러를 구현해 보완하였다.  
 (블로그 펌이니까 검증 필요)
 
### 컴파일 언어이자 인터프리터 언어 
- 컴파일 방식 : 
- 인터프리터 방식이란 코드 한 줄씩 기계어로 번역하는 방식이다.  
[모던 자바스크립트 Deep Dive](https://github.com/AtomicLiquors/Javascript_Wiki_Chb/blob/2a8eda3414bec5fa08ad2d31b6f353016fb4165a/1.%EC%83%81%EC%8B%9D%EA%B3%BC%20%EB%B2%84%EC%A0%84/%EC%96%B8%EC%96%B4%EC%9D%98%20%ED%8A%B9%EC%A7%95.md)

Java 인터프리터는 JAVAC 커맨드로 자바 프로그램을 중간 형태인 자바 바이트 코드로 컴파일한다. -- 컴파일러가 아니라..?   
```
자바 파일(*.java)을 바이트 코드로 작성된 파일(.class)로 변환한다.
```

이 바이트 코드를 자바 인터프리터가 한 줄씩 해석하여 기계어로 번역한다. 

그래서 .class 파일은 JVM만 해석할 수 있는 byte code로 작성되어 있으며, 
.class 파일에 대한 정의도 JVM에 나와 있다.

왜 자바는 컴파일과 인터프리터 방식을 병행하는 것일까?
**원래 자바의 JVM에서는 인터프리터 방식만 사용했었다.**  
하지만 성능의 문제가 발생했어서 JIT Compiler를 추가해서 성능의 효율을 끌어올렸다.   
이로 인해 자바는 컴파일과 인터프리터 방식을 병행해서 사용하게 됐다.  
(컴파일,  파트도 블로그 펌이라 검증 필요)
 
&nbsp;  
## 메서드 영역 
#### *method area*  
https://blog.wanzargen.me/16 
```
- 클래스 파일의 바이트 코드
- static으로 선언된 클래스 변수
```
&nbsp;  

메서드 영역은
**클래스 파일의 바이트 코드가 로드되는 곳**이다.
특정 동작을 수행하려면 메서드를 호출해야 할 텐데,  
그러기에 앞서 해당 메서드가 들어있는 클래스의 내용을 메모리 영역에 적재하는 것이다.

프로그램이 돌아갈 때 특정 클래스가 사용되면,   
JVM은 그에 해당하는 .class 파일을 분석하고,  
관련 정보[*class data*]를 메서드 영역에 저장한다.  
**static으로 선언된 클래스 변수** 또한 이 때 함께 저장한다.  
[클래스 변수 링크]
&nbsp;  

&nbsp;  
## 힙
#### *heap*
**인스턴스, 즉 인스턴스 변수가 생성되는 공간.**  
<!-- 
- static 없이 생성한 변수 말하는 거냐, 
- 아니면 인스턴스 주소를 저장한 변수 말하는 거냐?
- 확실하게 알아보자.
-->
먼저 힙의 구조는 아래와 같이 되어있다.

<img src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fuser-images.githubusercontent.com%2F51393021%2F132426039-0a07773f-1002-45ad-b009-2d04cdd816d9.png&blockId=ae3cbccf-2115-4b92-9a69-04d8a8e9ef66" width="80%">


### 영 제너레이션
영 제너레이션은 새롭게 생성된 객체가 할당되는 공간이다.  
영 제너레이션은 에덴과 서바이버 공간으로 나뉜다.

1. 객체가 힙메모리에 할당 되면 우선 에덴에 할당된다. 에덴 영역이 가득 찬다면, 마이너 GC(에덴 영역에서의 mark and sweep)가 일어난다.   
여기서 reachable해서 살아남은 객체는, survivor영역으로 이동한다.

2. 살아남아서 서바이버 영역으로 이동한 객체는 age가 증가한다.  
3. 또 다음 마이너 gc가 일어나면, 새로운 reachable 객체들은 서바이버 영역으로 이동하고, 기존 서바이버는 age가 1 증가한다.
4. 이 과정이 반복되어 age가 일정 임계점을 돌파하면, old generation 영역으로 이동(promotion)한다.

### 올드 제너레이션
영 제너레이션에서 특정 age가 넘은 참조 메모리들이 이동하는 공간이다.
이 공간이 가득차면, major GC(올드제너레이션에서의 mark and sweep)가 일어난다.

### 왜 영 제너레이션과 올드 제너레이션을 나눴을까?
GC 설계자들은 두가지 가설을 전제로 GC를 만들었다고 한다.
1. 대부분의 객체는 금방 접근 불가능한 상태가 된다. 
2. 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.
그래서 영 제너레이션과 올드 제너레이션을 나누어놓고 힙 전체에서 GC를 진행하지 않고 영 제너레이션 에서만 GC를 수행(minor GC)한다.  
여기서 대부분의 garbage가 수거되기 때문에, 메모리 낭비를 막을 수 있다.


&nbsp;  
&nbsp;  

## 호출스택
#### *call stack / execution stack*
메서드 작업에 필요한 메모리 공간.  
호출된 메서드를 위한 메모리가 스택에 할당된다.  
할당된 메모리는 다음을 위해 사용된다. 
```
- 매개변수 등 지역변수를 저장한다.
- 연산의 중간 결과를 저장한다.
```

메서드가 종료되면 할당된 메모리공간은 반환되고 비워진다.

|[==스택==]|
|:--:|
|하위 메서드|
|상위 메서드|
|main 메서드|

main메서드에서도 더 이상 수행할 코드가 없을 때,   
호출스택은 완전히 비워지고,  
프로그램이 종료된다. 

재귀함수 등으로 인해 호출 스택에 무한히 메서드가 쌓이는 것을   
"StackOverflow"라고 한다.  

&nbsp;  

### JVM에도 쓰레드가 있다.  
https://www.youtube.com/watch?v=v1gb397uFC4 8:09

JVM에 의존하는 쓰레드, CPU에 의존하는 쓰레드(Native Thread)가 별개로 존재한다.


&nbsp;  

### JVM의 메모리 유출
https://techblog.woowahan.com/2628/


몇 개 눈길 가는 구절을 옮겨봤지만 내용을 잘 알지는 못하겠고,   
전체 내용은 위 링크 참고할 것.

"트래픽이 많지 않았으나 api 응답 지연이 발생했습니다. 응답이 느린 api의 코드를 살펴봤지만, 특이점을 찾을 수 없었습니다. 장애로 번지기 전에 해결하고자 환경 복제 후 트래픽을 새로운 서버로 이관했습니다. 하지만 api 응답 지연이 재발하여 서버와 pinpoint를 자세히 살펴보게 되었습니다."  

"FullGC 가 계속 발생하지만 heap memory의 변화가 없었습니다. 이런 현상은 memory leak 이 발생한다는 의미인데 주문중계 api는 이전에도 운영 중이었고, 동일한 현상이 발생하지 않았던 서비스여서 무엇이 문제인지 알 수 없어 이전에 발생 여부를 확인해봤습니다."  


PARALLEL GC -> G1GC 변경하고 JVM 메모리 옵션 추가  
JDK8의 기본 GC는 PARALLEL GC입니다. 그래서 이 부분을 G1GC로 변경하면서 JVM 메모리 옵션도 추가하기로 했습니다.  
근본적인 해결 방법은 아니지만 STW(Stop the world)를 짧게 가져갈 수 있으니 할 수 있는 건 뭐든 해보기로 했습니다.  

문제가 발생했을 때 Heapdump 내려서 분석하기  
**단순히 코드만 보고 memory leak를 찾는 건 ‘모래밭에서 바늘 찾기’ 와 마찬가지였습니다.**   
해결을 위해 heapdump 분석이 필요했고, 관련 옵션을 추가했습니다.  


