[<< 메인으로](https://github.com/AtomicLiquors/Java_Wiki_Chb/blob/main/Readme.md)


# JVM의 메모리 구조
Byte Code는 기계어가 아니기 때문에 OS에서 바로 실행되지 않는다.   
이때 JVM은 OS가 ByteCode를 이해할 수 있도록 해석해준다.   

JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것이다.   
하지만 JVM의 해석을 거치기 때문에 c언어 같은 네이티브 언어에 비해 속도가 느렸다.
이런 단점은 JIT(Just In Time)컴파일러를 구현해 보완하였다.  
 (블로그 펌이니까 검증 필요)
 
&nbsp;  
## 메서드 영역 
___
#### *method area*  
프로그램이 돌아갈 때 특정 클래스가 사용되면,   
JVM은 그에 해당하는 .class 파일을 분석하고,  
관련 정보[*class data*]를 메서드 영역에 저장한다.  
static으로 선언된 클래스 변수 또한 이 때 함께 저장한다.  
[클래스 변수 링크]
&nbsp;  

&nbsp;  
## 힙
___
#### *heap*
**인스턴스, 즉 인스턴스 변수가 생성되는 공간.**  
- static 없이 생성한 변수 말하는 거냐, 
- 아니면 인스턴스 주소를 저장한 변수 말하는 거냐?
- 확실하게 알아보자.
&nbsp;  
&nbsp;  

## 호출스택
___
#### *call stack / execution stack*
메서드 작업에 필요한 메모리 공간.  
호출된 메서드를 위한 메모리가 스택에 할당된다.  
할당된 메모리는 다음을 위해 사용된다. 
- 매개변수 등 지역변수를 저장한다.
- 연산의 중간 결과를 저장한다.
  
메서드가 종료되면 할당된 메모리공간은 반환되고 비워진다.

|[==스택==]|
|:--:|
|하위 메서드|
|상위 메서드|
|main 메서드|

main메서드에서도 더 이상 수행할 코드가 없을 때,   
호출스택은 완전히 비워지고,  
프로그램이 종료된다. 

재귀함수 등으로 인해 호출 스택에 무한히 메서드가 쌓이는 것을   
"StackOverflow"라고 한다.  
