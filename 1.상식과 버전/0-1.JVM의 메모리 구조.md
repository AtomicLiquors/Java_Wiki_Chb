[<< 메인으로](https://github.com/AtomicLiquors/Java_Wiki_Chb/blob/main/Readme.md)


# JVM의 메모리 구조
.java파일 - 자연어 -> [컴파일러] - Byte Code -> [JVM] - 기계어 -> [OS]

JVM의 역할은 **자바 애플리케이션을 클래스 로더로 읽어들여 자바 API와 함께 실행하는 것**이다.   
JVM의 해석을 거친다는 점 때문에 c언어 같은 네이티브 언어에 비해 속도가 느렸다.
이런 단점은 JIT(Just In Time)컴파일러를 구현해 보완하였다.  
 (블로그 펌이니까 검증 필요)
 
&nbsp;  
## 메서드 영역 
#### *method area*  
https://blog.wanzargen.me/16 
```
- 클래스 파일의 바이트 코드
- static으로 선언된 클래스 변수
```
&nbsp;  

메서드 영역은
**클래스 파일의 바이트 코드가 로드되는 곳**이다.
특정 동작을 수행하려면 메서드를 호출해야 할 텐데,  
그러기에 앞서 해당 메서드가 들어있는 클래스의 내용을 메모리 영역에 적재하는 것이다.

프로그램이 돌아갈 때 특정 클래스가 사용되면,   
JVM은 그에 해당하는 .class 파일을 분석하고,  
관련 정보[*class data*]를 메서드 영역에 저장한다.  
**static으로 선언된 클래스 변수** 또한 이 때 함께 저장한다.  
[클래스 변수 링크]
&nbsp;  

&nbsp;  
## 힙
#### *heap*
**인스턴스, 즉 인스턴스 변수가 생성되는 공간.**  
<!-- 
- static 없이 생성한 변수 말하는 거냐, 
- 아니면 인스턴스 주소를 저장한 변수 말하는 거냐?
- 확실하게 알아보자.
-->
&nbsp;  
&nbsp;  

## 호출스택
#### *call stack / execution stack*
메서드 작업에 필요한 메모리 공간.  
호출된 메서드를 위한 메모리가 스택에 할당된다.  
할당된 메모리는 다음을 위해 사용된다. 
```
- 매개변수 등 지역변수를 저장한다.
- 연산의 중간 결과를 저장한다.
```

메서드가 종료되면 할당된 메모리공간은 반환되고 비워진다.

|[==스택==]|
|:--:|
|하위 메서드|
|상위 메서드|
|main 메서드|

main메서드에서도 더 이상 수행할 코드가 없을 때,   
호출스택은 완전히 비워지고,  
프로그램이 종료된다. 

재귀함수 등으로 인해 호출 스택에 무한히 메서드가 쌓이는 것을   
"StackOverflow"라고 한다.  

&nbsp;  

### JVM에도 쓰레드가 있다.  
https://www.youtube.com/watch?v=v1gb397uFC4 8:09

JVM에 의존하는 쓰레드, CPU에 의존하는 쓰레드(Native Thread)가 별개로 존재한다.


&nbsp;  

### JVM의 메모리 유출
https://techblog.woowahan.com/2628/


몇 개 눈길 가는 구절을 옮겨봤지만 내용을 잘 알지는 못하겠고,   
전체 내용은 위 링크 참고할 것.

"트래픽이 많지 않았으나 api 응답 지연이 발생했습니다. 응답이 느린 api의 코드를 살펴봤지만, 특이점을 찾을 수 없었습니다. 장애로 번지기 전에 해결하고자 환경 복제 후 트래픽을 새로운 서버로 이관했습니다. 하지만 api 응답 지연이 재발하여 서버와 pinpoint를 자세히 살펴보게 되었습니다."  

"FullGC 가 계속 발생하지만 heap memory의 변화가 없었습니다. 이런 현상은 memory leak 이 발생한다는 의미인데 주문중계 api는 이전에도 운영 중이었고, 동일한 현상이 발생하지 않았던 서비스여서 무엇이 문제인지 알 수 없어 이전에 발생 여부를 확인해봤습니다."  


PARALLEL GC -> G1GC 변경하고 JVM 메모리 옵션 추가  
JDK8의 기본 GC는 PARALLEL GC입니다. 그래서 이 부분을 G1GC로 변경하면서 JVM 메모리 옵션도 추가하기로 했습니다.  
근본적인 해결 방법은 아니지만 STW(Stop the world)를 짧게 가져갈 수 있으니 할 수 있는 건 뭐든 해보기로 했습니다.  

문제가 발생했을 때 Heapdump 내려서 분석하기  
**단순히 코드만 보고 memory leak를 찾는 건 ‘모래밭에서 바늘 찾기’ 와 마찬가지였습니다.**   
해결을 위해 heapdump 분석이 필요했고, 관련 옵션을 추가했습니다.  


