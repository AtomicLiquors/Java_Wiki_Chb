[<< 메인으로](https://github.com/AtomicLiquors/Java_Wiki_Chb)

&nbsp;  

# 예외처리

자바는 런타임 에러를 두 가지로 구분하였다.
- 에러*error* : 
  - 프로그램 코드가 수습할 수 심각한 에러. 
  - 한번 발생하면 복구가 불가능하다.  
   (메모리 부족, 스택오버플로우 등)
- 예외*exception* : 
  - 프로그램 코드가 수습 가능한, 비교적 심각성이 낮은 에러.
  - 단, 비정상 종료를 방지하려면  
   프로그래머가 적절한 코드를 작성하여 예외에 대비해 두어야 한다.
  - 대비하지 못한 예외는 *uncaught exception*이라 하며,   
	JVM의 예외처리기*UncaughtExceptionHandler*가   
	예외의 원인을 화면에 출력한다.

&nbsp;  
자바는 에러와 예외를 클래스로 정의해 두었으며,  
이들은 *Throwable*의 자식 클래스로 존재한다.  
예외가 발생하면, 그 종류에 해당하는 클래스의 인스턴스가 생성된다.
&nbsp;  
&nbsp;  

### 예외 클래스 구분
크게 두 가지로 구분한다.
- RuntimeException클래스
  - 프로그래머의 실수로 발생하는 예외들.
    - IndexOutOfBoundException :   
   배열의 범위를 벗어났다.
    - NullPointerException :   
     값이 null인 참조변수의 멤버를 호출하려고 했다.
    - ClassCastException :  
     클래스간 형변환이 잘못되었다.
	- ArithmeticException :  
	 정수를 0으로 나누려고 하였다.
	
- RuntimeException클래스가 아닌 클래스  
	(이하 기타 Exception클래스라고 부르도록 한다.)
  - 외부의 영향, 사용자의 동작으로 발생하는 예외들.
    - FileNotFoundException :   
   존재하지 않는 파일을 입력하였다.
    - ClassNotFoundException :   
   존재하지 않는 클래스를 호출하였다.
    - DataFormatException :   
     입력 데이터 형식이 잘못되었다.



## 예외처리
*Exception Handling*  

**프로그램 실행시 발생 가능한 예외를 대비하여 코드를 작성하는 것.**  
갑작스런 비정상 종료를 막고, 정상적인 실행 상태를 유지한다.

```java
public class ExceptionEx1 {

	public static void main(String[] args) {
		try {
            //try : 예외 발생 가능성이 있는 코드를 넣는다.
			int a = 22;
			int b = 0;
			System.out.println("a + b = " + (a + b));
			System.out.println("a - b = " + (a - b));
			System.out.println("a * b = " + (a * b));
			System.out.println("a / b = " + (a / b));
			//try문 내에서 예외가 발생하게 되면, 
			//발생 지점 이후의 코드는 실행되지 않는다.
			System.out.println("계산 완료!");

		} catch (Exception e) {
            //catch : 예외가 일어나면 실행되는 영역. 
			//예외 타입과 참조변수를 넣는다.
            //e는 발생하는 예외 객체를 가리킨다.

			//System.out.println("예외 메시지 : " + e.getMessage());
			System.err.println("예외 메시지 : " + e.getMessage());
			//System.out을 안 쓰고 System.err를 쓴 점에 주목해 달라.
            //err를 쓴 경우, 다른 에러 메시지처럼 콘솔에서 빨간색으로 출력된다.

            e.printStackTrace(); 
			//예외가 일어나면 추적(history)내용까지 출력. 디버깅할 때 많이 쓴다.
		}finally {//try-catch-finally
			//예외가 있든 없든 무조건 실행하는 구문이다.
			System.out.println("finally 실행");
		}
		
	}

}

```

- try catch 내부에 또다른 try catch를 작성할 수도 있다. 
  
- catch 블럭을 여러 개 만들 수도 있다.

```java

public class ExceptionEx1 {

	public static void main(String[] args) {
		try {

		} catch (Exception1 e1) {
            //특정 형태의 예외 Exception1이 발생하면 실행하는 코드.

			System.err.println("예외 메시지 : " + e.getMessage());

            e1.printStackTrace(); 
			
		} catch (Exception2 e2) {
			//첫 번째 catch 블록에서 감지된 예외가 없다면 아래 블록으로 내려온다.
			//또다른 형태의 예외 Exception2가 발생하면 실행하는 코드.
			e2.printStackTrace(); 
		}
	}
}

```

### 예외 메시지 출력
- printStackTrace() : 예외 발생 당시의 호출스택에 있던 메서드 정보, 예외 메시지를 출력한다.
- getMessage() : 발생한 예외 클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.

### Throws
```java
package ch03_1;

import java.io.FileNotFoundException;
import java.io.FileReader;

public class ExceptionEx6 {

	public static void main(String[] args) {
		try {
			FileReader fr = myRead("test.txt");
		}catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		
	}

	// thorws는 "여기서 일어나는 예외는 나를 호출한 곳에 던지겠다"라는 의미.
	// 최종적으로 사용하는 곳에서 예외처리를 한다.
	//잘 이해가 안되니까 나중에 책 보자.
	public static FileReader myRead(String name) 
			throws FileNotFoundException {
		FileReader fr = new FileReader(name);
		return fr;
	}
}
```

- 파일 읽기 관련 예외처리는 위의 Throws 예시와 ExceptionEx4.java 참조.