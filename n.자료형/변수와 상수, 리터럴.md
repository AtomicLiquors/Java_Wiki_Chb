## 변수와 상수, 리터럴

**변수*variable* :** — parameter(매개변수)하고는 정확히 무슨 차이인가?

프로그램에서 사용되는 자료를 저장하기 위하여,
**할당받은 메모리 공간의 주소 대신 부르는 이름**

프로그램 실행 중에 값 변경이 가능하다.

변수의 유형은 값의 종류, 그리고 메모리의 크기를 정의한다.

상수*constant* :

프로그램 내에서 변경되지 말아야 하는 값.
혹시 변경되는 경우...

리터럴 literal 프로그램에서 사용하는 모든 숫자 값, 논리 값 등

선언문 쓸 때 우리가 **넣어 주는 값**.

- 정수형 리터럴은 접미사 L이 붙으면 Long타입이다. 그렇지 않으면 Integer타입이다.
- 실수형 리터럴은 접미사 f(float), d(double)가 있다. 
f냐 d냐, 둘 중 하나기 때문에
d는 생략을 허용한다. 그래서 d는 잘 안쓴다.
- 접미사는 대소문자를 구분하진 않지만 소문자 l이 1과 헷갈리므로 L로 쓴다.

- 캐릭터 타입(char) 하나의 문자, 홑따옴표 ‘’로 묶는다.
- String : 여러 개의 문자, 큰따옴표 “”로 묶는다.
    - String은 공백을 허용하지만, char는 공백을 허용하지 않는다.

접두사 0이 붙으면 8진수다. 0100 

0x가 붙으면 16진수다. 0x100

0b가 붙으면 2진수다. 0b0101

**그 밖의 다른 접미사**

리터럴 10. 은 10.0에서 끝의 0이 생략된 것.

리터럴 .10은 0.10에서 첫 0이 생략된 것

둘 다 실수형이며, 접미사가 없으므로 double 타입이다.

리터럴 10f는 float타입 실수형 리터럴

접미사 e는  제곱 기호인데, 실수형에만 사용된다.

**변수와 리터럴의 타입 불일치**

- 범위가 변수 > 리터럴인 경우는 OK
    - int i = ‘A’라고 했을 때, A의 문자 코드인 65가 i에 저장된다
    “int > char”
    - long l = 123;
    - double d = 3.14f;
- 범위가 변수 < 리터럴인 경우는 에러가 발생한다.
    - int i = 30_0000_0000; 
    int의 범위인 ±20억을 초과한다.
    - long l = 3.14f;
    long타입은 8byte고, float타입은 4byte잖아?
    → 실수형이 저장할 수 있는 범위가 훨씬 넓어.
- byte, short변수에 int리터럴 저장 가능
    - byte b = 100;
    - byte b = 128; // byte의 범위 -128~127d을 벗어나므로 에러 발생.
