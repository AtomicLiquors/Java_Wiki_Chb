## 형변환
___
*Casting*

서로 다른 타입을 가진 변수/상수끼리 연산을 수행하기 전에,   
타입을 일치시키는 것.

&nbsp;
### 명시적 형변환 : (타입)피연산자

&nbsp;

```java
double d = 85.4;
int score = (int)d;
System.out.println(score);

//출력 결과 : 85
```


Q. 이 때 d의 값도 함께 변하나요?  
A. 아닙니다. 값을 읽어와서 알맞은 타입으로 바꾸는 것이지, 값 자체를 바꾸는 게 아닙니다.

&nbsp;

&nbsp;

&nbsp;



### 문자와 숫자 간 변환

1) 숫자 3을 문자 '3'으로 바꾸기.  
  "+ 0"


2) 문자를 숫자로 바꾸기.  
"- 0"

왜 0을 더하고 빼는지는 다음 장에서.

### 문자열로 변환
숫자, 문자를 문자열로 변환하기
+""

문자열을 정수/실수로 바꾸기
Integer.ParseInt()
Double.ParseDouble()

문자열을 숫자로 바꾸기
userString.charAt(idx)




왜 0을 더하고 빼냐? 다음 장에서.


### 묵시적 형변환
사실 형변환을 하지 않더라도 컴파일러가 생략된 형변환을 자동으로 수행해 줄 수 있다.
이 때, 컴파일러는 기존의 값을 최대한 보존할 수 있는 타입을 택한다.

```java
float f = 1234;
```

### 값 손실
*loss of data*   

```java 
byte b = 1000;
```
   
   
위와 같이 4byte짜리 int 타입을 1byte짜리 byte타입으로 변환하는 경우,  
크기의 차이만큼 잘려나간다.  
이런 경우 '값 손실'이 발생할 수 있다.  
   

컴파일러에서 다음과 같이 에러가 뜬다.
```
incompatible types: possible lossy conversion from int to byte
```

&nbsp;  
Eclipse에서는 다음처럼 에러가 뜬다.
```
Type mismatch : cannot convert from int to byte
```
&nbsp;  
그러나 다음과 같이 명시적인 형변환의 경우,  
이는 프로그래머가 의도한 것으로 간주하여 컴파일러가 에러를 일으키지 않는다.  
**단, 값 손실은 발생한다.**

```java 
byte b = (byte) 1000;
System.out.println(b);
//출력 결과 : -24
```

&nbsp;  
서로 다른 두 타입간의 연산에서는 표현범위가 더 넓은 타입으로 통일하여 연산하도록 하자.  
그쪽이 값손실의 위험이 적고, 더 올바른 결과를 내기 때문이다.