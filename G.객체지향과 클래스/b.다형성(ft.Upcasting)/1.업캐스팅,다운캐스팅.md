[<< 메인으로](https://github.com/AtomicLiquors/Java_Wiki_Chb)

&nbsp;  
# 업캐스팅, 다운캐스팅
**참조변수의 형변환**  
<u>단, 서로 상속관계에 있는 클래스 사이에 한하여.</u>    

- 목적은 **사용할 수 있는 멤버의 갯수를 조절**하는 것이다.
```
조상 <- 자손 : Up-casting
조상 -> 자손  : Down-casting
```

&nbsp;  
https://www.youtube.com/watch?v=3lSPC37IaNQ&t=10s  
"형변환 자체는 쉬워요. 업/다운캐스팅 구분, 형변환 연산자 생략 가능 여부는 다 자연스럽게 알게 됩니다. 중요한 게 아니에요."  
"실제 객체가 무엇이고 멤버 갯수를 넘느냐 마느냐, 에러가 날지 안 날지를 생각하셔야 돼요.
 이 말을 잘 이해하시길 바랍니다."  
"컴파일 단계에서는 실제 객체가 무엇인지를 판단하지 않아요. 그래서 통과가 됩니다. 실행할 때 오류가 나요."

&nbsp;  
### 형식
다음과 같이 (ClassName) 형태의 형변환 연산자를 사용해 준다.
```java
var1 = (ClassName)var2;
```

앞서 다형성 파트의 예제는 다음과 같이 형변환 연산자가 생략된 형태이다.
```java
//short ver.
Tv t = new SmartTv(); 

//long ver.
Tv t = (Tv)new SmartTv(); 

//full ver.
SmartTv c = new SmatTv();
Tv t = (Tv)c; 
```

## 형변환은 인스턴스를 건드리지 않는다.
참조변수의 타입을 변환하는 것이지, 인스턴스를 변환하는 것이 아니란 말이다.

```java
SmartTv c = new SmatTv();
Tv t = (Tv)c; 
```
여기서 t와 c는 동일한 메모리 주소에 들어있는 같은 객체를 가리킨다.
다만 그것을 가리키는 '리모컨'이 바뀌는 것이고, 
따라서 리모컨의 버튼 갯수가 그때그때 달라질 수 있는 거라고 표현하였다.

## 다운캐스팅은 형변환 연산자를 생략할 수 없다.
다룰 수 있는 멤버가 줄어드는 건 상관없는데,   
늘어나는 건 문제가 된다.  

&nbsp;  
# instanceof
참조변수의 형변환 가능 여부를 Boolean으로 반환한다.

형변환 전에 반드시 instanceof로 확인하는 과정을 거치도록 한다.

```java
void tuning(Car c){
    if(c instanceof FireEngine){
        FireEngine fe = (FireEngine)c;
    }
}
```

## 참조변수와 인스턴스 연결
상황 :  
 부모 클래스의 멤버변수와 같은 이름으로,   
 자손 클래스의 인스턴스 변수를 만들었다.  
 

 &nbsp;  
 분기 1)  
부모 타입의 참조변수가 자손 인스턴스를 참조하는 경우

 &nbsp;  
 분기 2)  
자손 타입의 참조변수가 자손 인스턴스를 참조하는 경우

 &nbsp;  
해당 변수명을 호출하면 어느 쪽의 변수가 나올까?  
 부모 클래스의 멤버변수?  
 자식 클래스의 인스턴스 변수?


Tip. 메서드는 참조변수 타입과 상관없이, 항상 실제 인스턴스의 메서드가 호출된다.


 &nbsp;  
 ```java
 정답)
 1) 조상 클래스에 선언된 멤버변수가 사용된다.
 2) 자식 클래스에 선언된 멤버변수가 사용된다.
 //뻔한 답이지만, 줄글로 적으면 너무 지지부진해서 일부러 문답식으로 나눠 적었다.
 ```

[예제 추가바람]