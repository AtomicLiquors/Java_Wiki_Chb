실수형은 실수를 저장하기 위한 타입이다.





소수는 그냥 쓰면  double유형이다.

float을 정의하고 싶으면, 소수 쓰고 f를 달아준다.

```jsx
double dnum = 2.15;
float fnum = 3.15f;
```

실수 유형에 데이터를 저장하면 정확한 값이 안 나오고 짤리거나 생략될 수가 있다.
밑에 코드는 그래서 쓰는 건가.

```jsx
public class DoubleTest01 {
	public static void main(String[] args) {
		double dnum = 0;
		for (int i = 0; i < 10000; i++) {
			dnum = dnum + 0.01;
		}
		System.out.println(dnum);
	}
}
```


*float : 연산 속도나 메모리가 우선일 때  
double : 더 큰 값의 범위나 더 큰 정밀도가 필요할 때*

|타입|저장 가능한 범위(양수)|정밀도|bit수|byte수|
|--|--|--|--|--|
|float|$1.4 * 10^{-45}$ ~ $3.4 *10^{38}$|7자리|32|4|
|double|$4.49* 10^{-324}$ ~ $1.8 *10^{308}$|15자리|64|8|

실수형은 소수점수도 표현해야 하기 때문에,  
얼마나 큰 값을 표현할 수 있는가? 만큼이나  
얼마나 0과 가깝게 표현할 수 있는가? 도 중요하다.

실수형에서는 Overflow가 발생하면 변수 값이 무한대가 된다.

실수형에서는 Underflow 또한 존재한다.  
실수형으로 표현 불가능할만큼 정말 작은 값이 되는 경우.  
(실수형의 양의 최솟값보다 더 작은 값이 되는 경우.)  
이 때 변수 값은 0이 된다.

Q. 어떻게 같은 4바이트인데 표현 범위가 그렇게 넓나요?  
A. 값을 저장하는 형식이 다르기 때문이다.  
실수형은 부호($S$), 지수($E$), 가수($M$) 세 부분으로 나뉘어 있다.  
저장은 다음과 같이 '10의 제곱을 곱한 형태'로 저장된다.

$(±M * 10^E)$

이는 IEEE754라는 표준을 따른 것이다.


&nbsp;  

**정밀도**  
정밀도가 $n$자리라는 말은, $n$자리의 10진수를 오차 없이 저장할 수 있다는 뜻이다.  
double 타입은 정밀도가 15자리이며,  
double을 쓰는 이유는 값이 더 크거나 작아서가 아니라  
소수 자릿수가 늘어나도 오차가 적고 정확하기 때문이다.  
double이라는 이름도 'float보다 2배 정도는 정밀하다'는 의미이다.

&nbsp;  

**보충) 자바의 정석 70페이지 보기.**
